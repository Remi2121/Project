import { LinearGradient } from 'expo-linear-gradient';
import { useRouter } from 'expo-router';
import React, { useMemo, useState } from 'react';
import { ScrollView, Text, TouchableOpacity, View } from 'react-native';
import RAW_RULES from '../../data/mood_rules.json'; // generated by the converter

/** Types */
type Rule = { pred: string; pct: number; reason: string };
type RuleMap = Record<string, Rule>;
type RealMood = 'happy' | 'sad' | 'angry' | 'tired' | 'sick' | 'neutral' | 'calm' | 'excited' | 'anxious';

/** UI mood choices (extend if needed) */
const CHOICES: { key: RealMood; label: string; emoji: string }[] = [
  { key: 'happy',  label: 'Happy',  emoji: 'üòä' },
  { key: 'sad',    label: 'Sad',    emoji: 'üò¢' },
  { key: 'angry',  label: 'Angry',  emoji: 'üò°' },
  { key: 'tired',  label: 'Tired',  emoji: 'ü•±' },
  { key: 'sick',   label: 'Sick',   emoji: 'ü§í' },
  { key: 'neutral',label: 'Neutral',emoji: 'üòê' },
];

/** Mapping between your real labels ‚Üî Excel ‚ÄúMood N‚Äù */
const REAL_TO_MOODN: Record<string, string> = {
  happy:'Mood 1', calm:'Mood 1', excited:'Mood 1',
  sad:'Mood 2', neutral:'Mood 2', anxious:'Mood 2', sorrow:'Mood 2',
  angry:'Mood 3',
  tired:'Mood 4',
  sick:'Mood 5',
};
const MOODN_TO_REAL: Record<string, RealMood> = {
  'Mood 1':'happy', 'Mood 2':'sad', 'Mood 3':'angry', 'Mood 4':'tired', 'Mood 5':'sick',
};
const EMOJI_TO_REAL: Record<string, RealMood> = {
  'üòä':'happy','üòê':'neutral','üò¢':'sad','üò°':'angry','ü•±':'tired','ü§í':'sick'
};

/** Utils */
const RULES = RAW_RULES as RuleMap;
const norm  = (s: any) => String(s || '').trim();
const lower = (s: any) => norm(s).toLowerCase();
const key5  = (a: string[]) => a.join('|');

const toMoodN = (input: string) => {
  const raw = norm(input);
  const m = /^mood\s*([1-5])$/i.exec(raw);
  if (m) return `Mood ${m[1]}`;
  if (EMOJI_TO_REAL[raw]) return REAL_TO_MOODN[EMOJI_TO_REAL[raw]] || 'Mood 2';
  return REAL_TO_MOODN[lower(raw)] || 'Mood 2';
};

const allEqual = (arr: string[]) => arr.length > 0 && arr.every((x) => x === arr[0]);

function majority(list: string[]) {
  const c: Record<string, number> = {};
  list.forEach((m) => (c[m] = (c[m] || 0) + 1));
  const pairs = Object.entries(c).sort((a, b) => b[1] - a[1]);
  if (!pairs.length) return { mood: 'Mood 2', tie: false, count: 0 };
  const [topM, topC] = pairs[0];
  const second = pairs[1]?.[1] ?? 0;
  return { mood: topM, tie: topC === second, count: topC };
}

const detectAlternate = (a: string[]) => {
  const [d1, d2, d3, d4, d5] = a;
  return d1 === d3 && d3 === d5 && d2 === d4 && d1 !== d2 ? d1 : null;
};

function fallbackPredict(last5N: string[]): Rule {
  const [d1, d2, d3, d4, d5] = last5N;

  if (allEqual(last5N)) return { pred: d5, pct: 1.0, reason: 'All past days same mood' };
  if (d3 === d4 && d4 === d5) return { pred: d5, pct: 1.0, reason: 'Last 3 days same mood' };
  if (d1 === d2 && d2 === d3 && d4 === d5 && d3 !== d4)
    return { pred: d5, pct: 0.9, reason: 'Last 2 days repeating' };
  if (d4 === d5) return { pred: d5, pct: 0.8, reason: 'Last 2 days same mood' };

  const alt = detectAlternate(last5N);
  if (alt) return { pred: alt, pct: 0.7, reason: 'Alternate pattern' };
  if (d1 === d5) return { pred: d5, pct: 0.8, reason: 'Start & end same mood' };
  if (d2 === d4) {
    const cnt = last5N.filter((x) => x === d2).length;
    return { pred: d2, pct: cnt >= 3 ? 0.65 : 0.6, reason: 'Every-other day pattern' };
  }

  const maj = majority(last5N);
  if (!maj.tie && maj.count >= 3) return { pred: maj.mood, pct: 0.75, reason: 'Majority in last 5' };
  if (!maj.tie) return { pred: maj.mood, pct: 0.66, reason: 'Majority in last 5' };

  return { pred: d5, pct: 0.6, reason: 'Mixed pattern; momentum from yesterday' };
}

function predictFromRules(last5: RealMood[]) {
  // Map to Excel space
  const last5N = last5.map((m) => toMoodN(m));
  const exact = RULES[key5(last5N)];
  if (exact) {
    return {
      moodReal: MOODN_TO_REAL[exact.pred] || (exact.pred as RealMood),
      pct: exact.pct,
      reason: exact.reason + ' (from Excel)',
    };
  }
  const fb = fallbackPredict(last5N);
  return {
    moodReal: MOODN_TO_REAL[fb.pred] || (fb.pred as RealMood),
    pct: fb.pct,
    reason: fb.reason + ' (fallback)',
  };
}

/** Chip row for a single day */
function DayRow({
  day,
  value,
  onPick,
}: {
  day: string;
  value: RealMood | null;
  onPick: (k: RealMood) => void;
}) {
  return (
    <View style={{ marginBottom: 14 }}>
      <Text style={{ color: '#cfe8ff', marginBottom: 8, fontWeight: '700' }}>
        {day} {value ? `‚Ä¢ ${value}` : ''}
      </Text>
      <View style={{ flexDirection: 'row', flexWrap: 'wrap', gap: 8 }}>
        {CHOICES.map((ch) => {
          const active = value === ch.key;
          return (
            <TouchableOpacity
              key={ch.key}
              onPress={() => onPick(ch.key)}
              style={{
                paddingHorizontal: 12,
                paddingVertical: 10,
                borderRadius: 20,
                backgroundColor: active ? 'rgba(0,224,255,0.28)' : 'rgba(255,255,255,0.08)',
                borderWidth: 1,
                borderColor: active ? 'rgba(0,224,255,0.7)' : 'rgba(255,255,255,0.12)',
                marginRight: 8,
                marginBottom: 8,
              }}
            >
              <Text style={{ color: '#fff', fontWeight: '700' }}>
                {ch.emoji} {ch.label}
              </Text>
            </TouchableOpacity>
          );
        })}
      </View>
    </View>
  );
}

/** Screen */
export default function PredictorFromRules() {
  const router = useRouter();

  const [d1, setD1] = useState<RealMood | null>(null);
  const [d2, setD2] = useState<RealMood | null>(null);
  const [d3, setD3] = useState<RealMood | null>(null);
  const [d4, setD4] = useState<RealMood | null>(null);
  const [d5, setD5] = useState<RealMood | null>(null);

  const canPredict = !!(d1 && d2 && d3 && d4 && d5);

  const result = useMemo(() => {
    if (!canPredict) return null;
    return predictFromRules([d1!, d2!, d3!, d4!, d5!]);
  }, [d1, d2, d3, d4, d5, canPredict]);

  return (
    <LinearGradient colors={['#0d0b2f', '#2a1faa']} style={{ flex: 1 }}>
      <ScrollView contentContainerStyle={{ padding: 16, paddingBottom: 32 }}>
        <TouchableOpacity onPress={() => router.back()} style={{ paddingVertical: 8 }}>
          <Text style={{ color: '#fff', fontSize: 18 }}>‚Üê Back</Text>
        </TouchableOpacity>

        <Text style={{ color: '#fff', fontSize: 24, fontWeight: '800', marginTop: 6 }}>
          Predict Day 6
        </Text>
        <Text style={{ color: '#b9c7ff', marginTop: 6 }}>
          Pick moods for the last 5 days. Uses rules compiled from your Excel.
        </Text>

        <View style={{ height: 12 }} />

        <DayRow day="Day 1" value={d1} onPick={setD1} />
        <DayRow day="Day 2" value={d2} onPick={setD2} />
        <DayRow day="Day 3" value={d3} onPick={setD3} />
        <DayRow day="Day 4" value={d4} onPick={setD4} />
        <DayRow day="Day 5" value={d5} onPick={setD5} />

        {/* optional CTA for UX; prediction happens live */}
        <TouchableOpacity
          disabled={!canPredict}
          onPress={() => {}}
          style={{
            marginTop: 4,
            alignSelf: 'flex-start',
            backgroundColor: canPredict ? '#00e0ff' : 'rgba(255,255,255,0.2)',
            paddingHorizontal: 16,
            paddingVertical: 12,
            borderRadius: 12,
          }}
        >
          <Text style={{ color: canPredict ? '#00121a' : '#eee', fontWeight: '800' }}>
            {canPredict ? 'Predict' : 'Select 5 days'}
          </Text>
        </TouchableOpacity>

        <View style={{ height: 16 }} />

        {/* Result card */}
        <View
          style={{
            padding: 16,
            borderRadius: 12,
            backgroundColor: 'rgba(0,224,255,0.12)',
            borderWidth: 1,
            borderColor: 'rgba(0,224,255,0.35)',
          }}
        >
          {result ? (
            <>
              <Text style={{ color: '#eaffff', fontSize: 18, fontWeight: '800' }}>
                Day 6 prediction -- {result.moodReal} {(result.pct * 100).toFixed(0)}%
              </Text>
              <Text style={{ color: '#cfe8ff', marginTop: 6 }}>Reason: {result.reason}</Text>
            </>
          ) : (
            <Text style={{ color: '#fff' }}>Pick all 5 days to see prediction.</Text>
          )}
        </View>
      </ScrollView>
    </LinearGradient>
  );
}
